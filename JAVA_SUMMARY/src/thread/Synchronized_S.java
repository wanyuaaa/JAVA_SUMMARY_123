package thread;

/**
 * @author wanyu
 * @createTime 2022-02-10 21:28
 *
 * synchronized
 *
 * 同步机制中的锁
 *   同步锁机制：
 *      在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。
 *      防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，
 *      使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。
 *   synchronized的锁是什么？
 *       任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。
 *       同步方法的锁：静态方法（类名.class）、非静态方法（this）
 *       同步代码块：自己指定，很多时候也是指定为this或类名.class
 *   注意：
 *       必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全
 *       一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）
 *
 * 同步的范围
 *  1、如何找问题，即代码是否存在线程安全？（非常重要）
 *      （1）明确哪些代码是多线程运行的代码
 *      （2）明确多个线程是否有共享数据
 *      （3）明确多线程运行代码中是否有多条语句操作共享数据
 *  2、如何解决呢？（非常重要）
 *      对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。
 *      即所有操作共享数据的这些语句都要放在同步范围中
 *  3、切记：
 *       范围太小：没锁住所有有安全问题的代码
 *       范围太大：没发挥多线程的功能。
 *
 * 释放锁的操作
 *       当前线程的同步方法、同步代码块执行结束。
 *       当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
 *       当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
 *       当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。
 *
 * 不会释放锁的操作
 *      线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行
 *      线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。
 *          应尽量避免使用suspend()和resume()来控制线程
 *
 * 线程的死锁问题
 *      死锁
 *          不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
 *          出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
 *      解决方法
 *          专门的算法、原则
 *          尽量减少同步资源的定义
 *          尽量避免嵌套同步
 *
 */
public class Synchronized_S {
}
